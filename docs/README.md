# Архитектура монолитного приложения

## Характеристики

- **Язык программирования**: Java  
- **База данных**: PostgreSQL  

## Архитектура

Приложение построено на монолитной архитектуре, где все компоненты (обработка запросов, бизнес-логика, доступ к данным) находятся в рамках одного приложения. 

## Взаимодействие

- **Синхронное взаимодействие**: Запросы обрабатываются последовательно, что может приводить к блокировкам.

## Масштабируемость

- **Ограниченная масштабируемость**: Монолитная архитектура затрудняет масштабирование отдельных модулей приложения.

## Развёртывание

- **Полное развёртывание**: Каждое изменение требует полной остановки приложения, что может приводить к временной недоступности сервиса.


# Определение доменов и границ контекстов

## Возможные домены

### 1. Управление устройствами
- Реализация логики включения и выключения устройств.
- Настройка целевой температуры.

### 2. Мониторинг данных
- Сбор данных с датчиков и их отображение.
- Ведение истории изменений температуры (при необходимости).

### 3. Аутентификация и авторизация
- Обеспечение аутентификации пользователей для управления устройствами.

## Границы контекстов

### 1. **Управление устройствами**
   - Включает бизнес-логику, связанную с включением/выключением систем отопления и настройкой температуры.

### 2. **Мониторинг**
   - Отвечает за интеграцию с датчиками температуры, сбор данных и отображение актуальной информации.

### 3. **Пользовательский интерфейс**
   - Является отдельным контекстом, отвечающим за взаимодействие с пользователями через веб-интерфейс или другие клиентские приложения.


# Проблемы монолитного подхода

## Проблемы

### 1. Масштабируемость
- Трудности при увеличении нагрузки:
  - Невозможно масштабировать только часть системы, приходится увеличивать ресурсы для всего приложения.
- Ограниченная возможность вертикального и горизонтального масштабирования отдельных компонентов.

### 2. Развёртывание
- Каждое изменение требует полной остановки приложения, что приводит к простоям.
- Невозможность частичного обновления системы.

### 3. Уязвимость к сбоям
- Проблемы в одном модуле могут нарушить работу всей системы.

### 4. Сложность развития
- Увеличение размера кода делает систему сложной в поддержке.
- Внесение изменений становится трудоёмким и рискованным.

### 5. Зависимость между компонентами
- Изменения в одном модуле могут повлиять на другие модули.
- Возрастает вероятность ошибок из-за высокой связанности компонентов.

## Рекомендации

1. **Переход на микросервисную архитектуру**:
   - Разделить систему на микросервисы по доменам:
     - Управление устройствами.
     - Мониторинг данных.
     - Аутентификация и авторизация.

2. **Выделение специализированных сервисов**:
   - Создать отдельный сервис для работы с данными датчиков, чтобы снизить нагрузку на основные модули.


## Диаграмма контекста (Context Diagram)
**Описание:**
Диаграмма визуализирует взаимодействие пользователей, датчиков и монолитного приложения.

```
@startuml
actor "Пользователь" as User
rectangle "Система управления домом" as System {
  rectangle "Управление устройствами" as DeviceControl
  rectangle "Мониторинг данных" as Monitoring
  rectangle "Аутентификация" as Authentication
}

rectangle "Нагревательные приборы" as HeatingDevices

User --> Authentication : Аутентификация
Authentication --> DeviceControl : Авторизованный доступ
User --> Monitoring : Просмотр данных
DeviceControl --> HeatingDevices : Управление нагревателями
Monitoring --> HeatingDevices : Сбор данных

@enduml


```

## План действий для проектирования новой архитектуры

1. **Декомпозиция монолитного приложения на микросервисы**

На основе выделенных доменов и границ контекстов, создадим следующие микросервисы:

### 1. Управление устройствами
- Логика включения/выключения устройств.
- Настройка целевой температуры.
### 2. Мониторинг данных
- Сбор данных с датчиков.
- Поддержка истории изменений температуры.
### 3. Аутентификация и авторизация
- Управление пользователями, их аутентификацией и правами доступа.
### 4. Пользовательский интерфейс (UI)
- Веб-интерфейс для взаимодействия пользователей с системой.
### 5. Обработка данных
- Использование Kafka для асинхронной обработки данных, например, агрегация данных датчиков или оповещения.


2. **Определение взаимодействий**
### 1. API Gateway
- Центральная точка входа для всех клиентских запросов.
- Роутинг запросов к соответствующим микросервисам.
### 2. Шина данных (Kafka)
- Используется для асинхронного обмена сообщениями между микросервисами, например:
- Отправка данных от датчиков к мониторингу.
- Триггеры событий, таких как изменения в управлении устройствами.
### 3. Микросервисы
- Управление устройствами и Мониторинг данных взаимодействуют через Kafka для обработки команд и данных.
- Аутентификация и авторизация проверяет права доступа для других сервисов через REST API.
### 4. База данных
- Каждому микросервису предоставляется собственная база данных (паттерн Database per Service).


3. **Визуализация архитектуры**
### C4: Уровень контейнеров

```
@startuml
!define RECTANGLE rectangle
!define CLOUD cloud
!define DATABASE database

actor "Пользователь" as User

CLOUD "API Gateway" as Gateway

RECTANGLE "Микросервисы" {
    RECTANGLE "Управление устройствами" as DeviceService
    RECTANGLE "Мониторинг данных" as MonitoringService
    RECTANGLE "Аутентификация и авторизация" as AuthService
    RECTANGLE "Обработка данных" as DataProcessing
    RECTANGLE "Пользовательский интерфейс (UI)" as UIService
}

CLOUD "Kafka" as Kafka
DATABASE "База данных: Управление устройствами" as DeviceDB
DATABASE "База данных: Мониторинг" as MonitoringDB
DATABASE "База данных: Аутентификация" as AuthDB

cloud "Датчики (Sensors)" as Sensors
cloud "Устройства нагрева (Heating Devices)" as HeatingDevices

User --> Gateway : HTTP Запросы
Gateway --> AuthService : Аутентификация
Gateway --> UIService : Веб-интерфейс
Gateway --> DeviceService : Управление устройствами
Gateway --> MonitoringService : Запрос данных

DeviceService --> DeviceDB : Чтение/Запись
MonitoringService --> MonitoringDB : Чтение/Запись
AuthService --> AuthDB : Проверка данных

DeviceService --> Kafka : Публикация событий
MonitoringService --> Kafka : Публикация данных
DataProcessing --> Kafka : Подписка на события

Sensors --> MonitoringService : Отправка данных
DeviceService --> HeatingDevices : Управление устройствами

@enduml


```

### C4: Уровень кода (Пример: Обработчик команд)

```
@startuml
class CommandHandler {
    + handleCommand(command: DeviceCommand): Response
    - validateCommand(command: DeviceCommand): bool
    - sendEvent(event: DeviceEvent)
}

class DeviceCommand {
    + id: UUID
    + type: String
    + targetTemperature: Float
}

class DeviceEvent {
    + id: UUID
    + type: String
    + timestamp: DateTime
}

CommandHandler --> DeviceCommand
CommandHandler --> DeviceEvent
@enduml

```

4. **Рекомендации**

- Использовать Kafka для обеспечения высокой скорости обмена данными между микросервисами.
- Применить API Gateway для унификации точек доступа.
- Разделить базы данных для обеспечения независимости микросервисов.
- Для каждого микросервиса предусмотреть мониторинг (например, через Prometheus) и логи (например, через ELK-стек).


## 1. Идентификация сущностей и атрибутов

### Пользователь (User)
- id: UUID (уникальный идентификатор пользователя)
- username: строка (имя пользователя)
- email: строка (электронная почта)
- password_hash: строка (хеш пароля)
- role: строка (роль пользователя, например, "администратор", "пользователь")

### Дом (House)
- id: UUID (уникальный идентификатор дома)
- user_id: UUID (внешний ключ к сущности User — кто является владельцем дома)
- address: строка (адрес дома)
- name: строка (название дома, например, "Дом на даче")

### Устройство (Device)
- id: UUID (уникальный идентификатор устройства)
- type_id: UUID (внешний ключ к сущности DeviceType — тип устройства)
- house_id: UUID (внешний ключ к сущности House — дом, к которому принадлежит устройство)
- serial_number: строка (серийный номер устройства)
- status: строка (текущее состояние устройства, например, "включено", "выключено")
### Тип устройства (DeviceType)
- id: UUID (уникальный идентификатор типа устройства)
- name: строка (название типа устройства, например, "термостат", "обогреватель")
- Модуль (Module)
- id: UUID (уникальный идентификатор модуля)
- device_id: UUID (внешний ключ к сущности Device — устройство, к которому принадлежит модуль)
- name: строка (название модуля, например, "отопление", "освещение")
### Телеметрия (TelemetryData)
- id: UUID (уникальный идентификатор записи телеметрии)
- device_id: UUID (внешний ключ к сущности Device — устройство, к которому относятся данные)
- temperature: float (температура)
- timestamp: datetime (время записи данных)

## 2. Связи между сущностями

- Пользователь — Дом: один пользователь может владеть несколькими домами, каждый дом принадлежит только одному пользователю (1
).
- Дом — Устройство: один дом может содержать несколько устройств, но каждое устройство привязано только к одному дому (1
).
- Устройство — Телеметрия: одно устройство может генерировать несколько записей телеметрии (1
).
- Устройство — Модуль: одно устройство может включать несколько модулей, но каждый модуль принадлежит только одному устройству (1
).
- Тип устройства — Устройство: тип устройства связан с множеством устройств, но каждое устройство имеет только один тип (1
).

## 3. ER-диаграмма 

```
@startuml
entity "Пользователь" as User {
  +id: UUID
  +username: string
  +email: string
  +password_hash: string
  +role: string
}

entity "Дом" as House {
  +id: UUID
  +user_id: UUID
  +address: string
  +name: string
}

entity "Устройство" as Device {
  +id: UUID
  +type_id: UUID
  +house_id: UUID
  +serial_number: string
  +status: string
}

entity "Тип устройства" as DeviceType {
  +id: UUID
  +name: string
}

entity "Модуль" as Module {
  +id: UUID
  +device_id: UUID
  +name: string
}

entity "Телеметрия" as TelemetryData {
  +id: UUID
  +device_id: UUID
  +temperature: float
  +timestamp: datetime
}

User ||--o{ House : "Владелец"
House ||--o{ Device : "Содержит"
Device ||--o{ TelemetryData : "Генерирует"
Device ||--o{ Module : "Содержит"
DeviceType ||--o{ Device : "Определяет тип"
@enduml

```