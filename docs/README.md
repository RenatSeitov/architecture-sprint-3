# Архитектура монолитного приложения

## Характеристики

- **Язык программирования**: Java  
- **База данных**: PostgreSQL  

## Архитектура

Приложение построено на монолитной архитектуре, где все компоненты (обработка запросов, бизнес-логика, доступ к данным) находятся в рамках одного приложения. 

## Взаимодействие

- **Синхронное взаимодействие**: Запросы обрабатываются последовательно, что может приводить к блокировкам.

## Масштабируемость

- **Ограниченная масштабируемость**: Монолитная архитектура затрудняет масштабирование отдельных модулей приложения.

## Развёртывание

- **Полное развёртывание**: Каждое изменение требует полной остановки приложения, что может приводить к временной недоступности сервиса.


# Определение доменов и границ контекстов

## Возможные домены

### 1. Управление устройствами
- Реализация логики включения и выключения устройств.
- Настройка целевой температуры.

### 2. Мониторинг данных
- Сбор данных с датчиков и их отображение.
- Ведение истории изменений температуры (при необходимости).

### 3. Аутентификация и авторизация
- Обеспечение аутентификации пользователей для управления устройствами.

## Границы контекстов

### 1. **Управление устройствами**
   - Включает бизнес-логику, связанную с включением/выключением систем отопления и настройкой температуры.

### 2. **Мониторинг**
   - Отвечает за интеграцию с датчиками температуры, сбор данных и отображение актуальной информации.

### 3. **Пользовательский интерфейс**
   - Является отдельным контекстом, отвечающим за взаимодействие с пользователями через веб-интерфейс или другие клиентские приложения.


# Проблемы монолитного подхода

## Проблемы

### 1. Масштабируемость
- Трудности при увеличении нагрузки:
  - Невозможно масштабировать только часть системы, приходится увеличивать ресурсы для всего приложения.
- Ограниченная возможность вертикального и горизонтального масштабирования отдельных компонентов.

### 2. Развёртывание
- Каждое изменение требует полной остановки приложения, что приводит к простоям.
- Невозможность частичного обновления системы.

### 3. Уязвимость к сбоям
- Проблемы в одном модуле могут нарушить работу всей системы.

### 4. Сложность развития
- Увеличение размера кода делает систему сложной в поддержке.
- Внесение изменений становится трудоёмким и рискованным.

### 5. Зависимость между компонентами
- Изменения в одном модуле могут повлиять на другие модули.
- Возрастает вероятность ошибок из-за высокой связанности компонентов.

## Рекомендации

1. **Переход на микросервисную архитектуру**:
   - Разделить систему на микросервисы по доменам:
     - Управление устройствами.
     - Мониторинг данных.
     - Аутентификация и авторизация.

2. **Выделение специализированных сервисов**:
   - Создать отдельный сервис для работы с данными датчиков, чтобы снизить нагрузку на основные модули.


## Диаграмма контекста (Context Diagram)
**Описание:**
Диаграмма визуализирует взаимодействие пользователей, датчиков и монолитного приложения.

```
@startuml
!define RECTANGLE rectangle
!define CLOUD cloud
!define DATABASE database

actor "Пользователь" as User
CLOUD "Датчики температуры" as Sensors
RECTANGLE "Монолитное приложение" as Monolith {
    RECTANGLE "Управление устройствами" as DeviceControl
    RECTANGLE "Мониторинг данных" as Monitoring
    RECTANGLE "Аутентификация и авторизация" as Auth
    RECTANGLE "Пользовательский интерфейс" as UI
}
DATABASE "База данных" as Database

User --> Auth : Аутентификация
User --> UI : Взаимодействие через веб-интерфейс
UI --> DeviceControl : Управление устройствами
UI --> Monitoring : Отображение данных

Sensors --> Monitoring : Отправка данных
Monitoring --> Database : Хранение истории данных
DeviceControl --> Database : Чтение и запись конфигурации устройств
Auth --> Database : Проверка данных пользователей

@enduml

```